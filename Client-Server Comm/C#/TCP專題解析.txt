TCP Server 專題解析
CSharp
{{Sever 
{{程式碼 :
using System.Net; # 提供IP位址相關類別
using System.Net.Sockets; # 提供建立TCP/UDP等協議的工具
using System.Text; # 提供字串與文字編碼功能
class Server # 定義Server
{
    static void Main(string[] args) # Main方法作為程式進入點
    {
		TcpListener listener = new TcpListener(IPAddress.Any, 9000);
		# 建立一個TcpListener物件，此物件將監聽所有本機IP (IPAddress.Any) 的9000埠口
		# 9000為自訂埠口，用避免與常用服務(HTTP-80、HTTPS-443、MySQL等)衝突
		listener.Start(); # 啟動listener，開始等待客戶端連線
		Console.WriteLine("==== Server started ===="); # 輸出訊息提示伺服器已啟動
		while (true) # 用無限迴圈一直等待客戶端連線
        {
            var client = listener.AcceptTcpClient(); 
			# AcceptTcpClient()是阻塞呼叫，直到有連線進入才繼續執行
            Console.WriteLine("==== Client accepted ====");
			# 連線接收完成後，輸出客戶端已連線提示
            var stream = client.GetStream(); // stream 傳送接收的文字
			# 從TCP客戶端物件client取得網路資料流(NetworkStream)，用來傳送和接收資料。
            var writer = new StreamWriter(stream, Encoding.UTF8)
			# 建立StreamWriter以文字方式寫入網路資料流，指定UTF-8編碼，確保中文和特殊字元可正常傳送
            {
                AutoFlush = true
				# 寫入後自動清空緩衝區，立即送出資料
            };
            Random random = new Random(); 
			# 建立隨機數產生器，用來模擬機器傳送的隨機資料
            while (client.Connected) # 在客戶端連線的情況下持續執行
            {
                var value = random.Next(0, 50); # 隨機產生0到49之間的整數
                writer.WriteLine(value); # 將該整數以文字一行傳送到客戶端
                Console.WriteLine($"Sent : {value} "); # 在主控台印出送出的數字
                Thread.Sleep(1000); # 讓執行緒暫停1秒
            }
        }
    }
}
}}
{{總結 : 
	   一個基本TCP文字伺服器，會偵聽9000端口，當有客戶端連線時，就每秒隨機產生0~49的數字
	   並傳送給該客戶端，直到連線被中斷。它的用途可以是模擬真實機器訊號傳輸(如感測器輸出)，
	   以便進一步開發網路應用。
}}
{{流程 :
  建立TCP伺服器監聽器 > 開始監聽 > 持續接收連線請求 > 連線成功 > 取得資料流 > 建立資料寫入器 > 檢查連線 > 傳遞資料
}}
{{知識 :
  System.Net - 網路位址與網路相關資訊
  			- IPAddress - 表示 IP 位址 - IPAddress.Any, Parse()
  			  Dns - 域名查詢 - Dns.GetHostEntry()
  			  IPEndPoint - 表示 IP 和埠口的組合(通常搭配 socket 使用)
  System.Net.Sockets - TCP/UDP Socket 通訊的API
  				   - TcpListener - TCP伺服器用來接收連線(server)
  					 TcpClient - TCP用戶端（client）
  					 Socket - 較底層的通訊控制，可處理 TCP/UDP
  					 NetworkStream - 將網路資料當作資料流處理(搭配 TcpClient 使用) 
  System.Text - 處理文字編碼與解碼(文字 ↔ 位元組)
  			- Encoding.UTF8 - 取得 UTF-8 編碼器(常見網路編碼)
  			  Encoding.ASCII - ASCII 編碼器
  			  Encoding.GetEncoding("編碼名稱") - 自訂其他語系編碼(如 Big5, Shift-JIS)
  TcpListener - .NET提供的類別，建立 TCP 伺服器監聽器 # 接受來自 TCP 用戶端的連線。
  			  - new TcpListener(IPAddress.Any, 9000); - 建構子，指定要監聽哪個IP與Port(埠口)
  			  								   - IPAddress.Any - 監聽本機所有網卡的IP，指定用IPAddress.Parse("192.168.1.10")
  			  								   - 9000 監聽的埠號，自訂通訊通道 - 0~65535：合法 TCP/UDP 埠口範圍  
  			  																   0~1023：保留系統埠口（如 HTTP 80、FTP 21、DNS 53）
  			  																   1024~49151：註冊埠口
  			  																   49152~65535：動態私有埠口（適合開發測試）
  			  - 方法 - Start() - 開始監聽連線（不呼叫會無效）。
  					   AcceptTcpClient() - 等待並接受 TCP 客戶端(阻塞) - TcpClient
  					   # 阻塞 - 卡住目前這行程式，直到有用戶端接入
  					   Pending() - 是否有用戶端正在嘗試連線(非阻塞) - bool		
  					   Stop() - 停止監聽
  TcpClient - 屬性 - Connected - bool - 是否「認為」目前仍處於連線狀態（不完全可靠）
  				   Client - Socket - 存取底層的 Socket 物件，可做更進階的控制
  				   Available - int - 接收緩衝區中目前可讀的位元組數量
  				   ReceiveBufferSize - int - 接收緩衝區大小（預設 8192 bytes）
  				   SendBufferSize - int - 傳送緩衝區大小
  				   ReceiveTimeout - int(ms) - 讀取逾時(毫秒)，0 表示不逾時
  				   SendTimeout - int(ms) - 寫入逾時(毫秒)
  				   NoDelay - bool - 設定是否停用 Nagle 演算法(延遲聚集小封包)
  				   GetStream() - NetworkStream - 傳回可讀寫的網路資料流物件
  NetworkStream - var stream = client.GetStream(); - TCP 通訊中取得資料傳輸通道(NetworkStream) # 收送資料的唯一通道 
  StreamWriter - 建立文字寫入器 - StreamWriter writer = new StreamWriter(stream, Encoding.UTF8); # Encoding.UTF8 - 表示將文字轉換成 UTF-8 編碼
			   方法 - WriteLine(string) - 寫入字串，並加上換行符號 # Line 拿掉不換行
					  Flush() - 手動清空 buffer，強制寫入資料
					  Close() - 關閉 writer（釋放資源）
					  Dispose() - 一樣是釋放資源，常透過 using 自動處理
			   屬性 - AutoFlush(bool) - 是否在每次寫入後自動清空緩衝區
			   		 # 會先把資料寫進 buffer(緩衝)，資料滿了或.Flush()才送出
			   		 # AutoFlush = true -  每次呼叫寫完，資料都會立刻送出 # 語法糖 - 物件初始化器(在建立物件之後立刻設定屬性)
			   	   - BaseStream(Stream) - 取得底層資料流
			   	   - Encoding(Encoding) - 取得寫入時所使用的文字編碼
			   	   - NewLine(string) - 控制 writer.WriteLine()使用的換行符號
}}
}}
{{Server2
{{程式碼 : 
using System.Net;
using System.Net.Sockets;
using System.Text;

namespace Project_Server;

public class Server2
{
    public static void Main(string[] args)
    {
        TcpListener listener = new TcpListener(IPAddress.Any, 9000);
        listener.Start();
        Console.WriteLine("==== Server started ====");
        while (true)
        {
            // 主 Thread 專門客戶端連線
            TcpClient client = listener.AcceptTcpClient();
            Console.WriteLine("==== Client accepted ====");
            
            // 為每一個 client 開 Thread
            Thread clientThread = new Thread(HandleClient);
			# 建立新的執行緒clientThread，指定執行的方法是HandleClient
            clientThread.IsBackground = true;
			# 設定此執行緒為背景執行緒，主程式結束背景執行緒會自動停止。
            clientThread.Start(client);
			# 啟動執行緒並將目前的client傳入
        }
    }

    public static void HandleClient(object obj)
    {
        TcpClient client = (TcpClient)obj;
		# HandleClient方法負責資料傳送，參數是object型態，因此需轉型為TcpClient
        try
        {
            NetworkStream stream = client.GetStream();
            StreamWriter writer = new StreamWriter(stream, Encoding.UTF8)
            {
                AutoFlush = true
            };
			
            Random random = new Random();
            while (client.Connected)
            {
                int value = random.Next(100);
                writer.WriteLine(value);
                Console.WriteLine($"[Client {Thread.CurrentThread.ManagedThreadId}]Sent : {value}");
                # 在主控台輸出該隨機數字並加上目前執行緒ID，方便識別是哪個客戶端連線
				Thread.Sleep(1000);
            }
        }
        catch (Exception e)
        {
            Console.WriteLine($"Client {Thread.CurrentThread.ManagedThreadId}  Error: {e.Message}");
			# 若傳輸過程有例外錯誤，印出錯誤訊息與對應的執行緒ID方便除錯
		}
        finally
        {
            client.Close(); // 確保連線正常釋放
			# finally區塊確保即使發生錯誤，都會關閉客戶端連線並印出「伺服器斷開連線」訊息。
            Console.WriteLine("==== Sever disconnected ====");
        }
    }
}
}}
{{
}}
{{新增功能 : 
  1. 多執行緒 - Thread clientThread = new Thread(HandleClient); 
			  # 在接受到客戶端連線後，會建立獨立執行緒，使主執行緒能等待下一個客戶連線，實現同時處理多個客戶。
  2. 背景執行 - clientThread.IsBackground = true;
			  # 當主執行緒結束時，自動結束背景執行緒
  3. 封裝客戶端連線處理邏輯 - public static void HandleClient(object obj) - 結構清晰及功能模組化
						   # 執行緒方法接受object參數，因為多執行緒API設計如此；內部需要轉型回原本類型
  4. 錯誤處理與釋放資源 - try{ 處理資料流 } catch(Exception e){ 印出錯誤訊息 } finally{ client.Close(); 確保釋放資源}
						# 防止執行緒內部發生例外造成整個伺服器崩潰
  5. 辨識多個客戶端連線 - Thread.CurrentThread.ManagedThreadId
}}
{{新增流程 :
  主程式 - 持續接收連線請求 > 連線成功 > # 建立執行緒並指定方法 > 設定為背景執行緒 > 執行緒啟動..
  HandleClient - 將接收物件轉為TcpClient > 嘗試取得資料流... > 釋放資源
									> 例外 - 印出該執行緒ID及錯誤原因
}}
{{新增知識 :
  Thread - 概念 - 實作多工處理的基本單位
		   建立 - Lambda - Thread t = new Thread(() => Method(client));
				  Task - Task.Run(() => Method(client)); # 預設為背景執行緒
				  方法參考 - Thread t = new Thread(Method); 
				  			 t.Start(parameter);
				  			 '''
				  			 不可 Thread clientThread = new Thread(HandleClient(client));
				  			 等同於Thread clientThread = new Thread(null);
				  			 HandleClient(client) 是立即執行，不是方法參考，而通常回傳值為null，
				  			 '''
		   方法 - Start() - 啟動執行緒        
                  Join() - 等待此執行緒完成  
				  Sleep(ms) - 暫停目前執行緒一段時間    
				  Abort() - 強制終止執行緒(已不推薦)
		   屬性 - IsAlive - 是否還在執行中                  
				  IsBackground - 設為背景執行緒，主程式結束會自動終止 
				  ManagedThreadId - 執行緒ID，可用來識別不同 thread 
}}
}}
{{Server3
{{新增內容 : 
  string data = 
    $"{{\"ECG\":{random.Next(50, 100)}, \"BP\":{random.Next(80, 120)}, \"Pluse\": {random.Next(30, 60)}}}";
  # 傳送一組模擬的 JSON 格式數據（如：{"ECG":75,"BP":110,"Pluse":55}）# 心臟電活動
  byte[] bytes = Encoding.UTF8.GetBytes(data);
  # 字串轉為位元組陣列(UTF-8 編碼)
  stream.Write(bytes, 0, bytes.Length);
  # 要傳送的資料（位元組陣列）,傳送的起始位置,傳送的長度
}}
{{新增知識 :
  資料寫入方法 - 1. byte[] bytes = Encoding.UTF8.GetBytes(data);
			       stream.Write(bytes, 0, bytes.Length);
				2. StreamWriter writer = new StreamWriter(stream, Encoding.UTF8)
				   writer.WriteLine(value);
  詳細比較 :
  寫法　　　  | stream.Write(...)	          |  StreamWriter.WriteLine(...)
  類型	     | 低階寫入（位元組）	              |  高階寫入（文字）
  資料類型	 | byte[]（二進位）	              |  string（字串）
  編碼處理	 | 你自己決定用什麼編碼(如 UTF-8)　 |  自動使用建構時指定的編碼
  緩衝區	     | 無額外緩衝（立刻寫）	          |  有緩衝，可能要 .Flush() 才寫入
  換行符號	 | 不會自動加換行	WriteLine()       |  會自動加 \r\n
  控制性	     | 更精細(傳送圖片、檔案、JSON...)   |	 限定在傳送純文字為主
  效能	     | 更高效能，少一層抽象	          |  程式碼更簡潔但稍慢一點
  ⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺
  法一、傳輸資料方法
  資料類型　　|  	傳送方式	           |    	注意事項
  JSON 文字  |  編碼為 UTF-8 的 byte[]  |  結尾建議用特定符號分隔，如 \n
  檔案       |  將檔案讀成 byte[] 傳送　 |  可用 File.ReadAllBytes()
  圖片       |  同檔案處理，無差別對待	   |  建議在傳送前傳 metadata（長度、格式）
  ⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺
  JSON - 以文字儲存結構化資料 - 網頁與伺服器之間資料傳輸的標準格式 # 可有空值
		 規則 - {} - 表示物件(key-value) | [] - 表示陣列 | " - 字串與欄位名稱 | : - 鍵與值之間用冒號 | , - 欄位之間用逗號分隔		                                                             
}}
}}
{{Client2
{{程式碼 :
using System.Net.Sockets;
using System.Text;

namespace Server_Client;

public class Client2
{
    public static void Main(string[] args)
    {
        int totalClients = 3;
		# 要建立 3 個客戶端
        for (int i = 0; i < totalClients; i++)
        {
            int clientId = i;
            Thread thread = new Thread(() => RunClient(clientId));
			# 每個 client 在自己的執行緒運行
            thread.IsBackground = true;
			# 背景執行緒，主程式結束後會被終止
            thread.Start();
            Thread.Sleep(1000);
			# 每個 client 啟動間隔 1 秒（避免太擠）
        }
        Console.ReadKey();
    }

    static void RunClient(int clientId)
    {
        try
        {
            TcpClient client = new TcpClient("127.0.0.1", 9000);
			# 嘗試連線到本機的 TCP 伺服器（port 9000）
            NetworkStream stream = client.GetStream();
			# 取得資料流物件來收資料
            StreamReader reader =  new StreamReader(stream, Encoding.UTF8);
			# 包裝成文字讀取器（以 UTF-8 解碼）
            int threadId = Thread.CurrentThread.ManagedThreadId;
			# 取得目前執行緒 ID（用來識別是哪個 client）
            Console.WriteLine($"Client {clientId} Thread Id: {threadId}");

            string line;
            while ((line = reader.ReadLine()) != null)
			# 持續讀取伺服器傳來的文字
            {
                Console.WriteLine($"Client {clientId} Received: {line}. Thread Id: {threadId}");
            }
            Console.WriteLine("Disconnected");
        }
        catch (Exception e)
        {
            Console.WriteLine($"Client {clientId} Error. Reason: {e.Message}");
            throw;
			# 顯示錯誤原因並重新拋出例外
        }
    }
}
}}
{{流程 : 
  設定參數決定客戶端數量 > for迴圈連續建立客戶端執行緒 > 開始執行 > 嘗試連線伺服器(失敗顯示原因並拋出例外) 
  > 取得資料流 > 建立讀取器解析 > while迴圈持續接收資料
}}
{{知識 : 
  TcpClient - TcpClient client = new TcpClient("127.0.0.1", 9000); # "127.0.0.1" 為本機IP位置
			public TcpClient(string hostname, int port)
  StreamReader - StreamReader reader = new StreamReader(stream, Encoding.UTF8);
			  - 方法 - Read() - 讀取下一個字元，回傳int(可轉成 char) # 若已無資料，回傳 -1
					  ReadLine() - 讀取一整行，直到遇到 \n 或 \r\n，回傳 string # 若資料結束，回傳 null。
					  ReadToEnd() - 一次讀完"剩下的全部內容" # 資料量不大
					  Peek() - 查看下一個字元，回傳 int # 不移動讀取位置
					  DiscardBufferedData() - 清除內部快取的資料 # 強制從底層 Stream 重新讀取(較少用)
					  Close() / Dispose() - 關閉 reader(釋放資源，通常不需手動呼叫，using 區塊會自動處理)
			    屬性 - EndOfStream - 回傳 true 表示資料已讀完 # 類似 ReadLine() 回傳 null
			    	  CurrentEncoding - 查看使用的編碼類型 - 例 UTF8
			    	  BaseStream - 回傳底層的原始資料流
}}
}}
{{Client3
{{新增功能 :
  byte[] buffer = new byte[1024]; - 定義一個長度為 1024 的位元 = 1KB 陣列 # 資料緩衝區 - 暫存從網路串流
  # 陣列太小/大 - 切斷資料/浪費記憶體
  int read = stream.Read(buffer, 0, buffer.Length); - (存放陣列,位置0開始存放,最多讀取資料) # 阻塞式			
  # 實際長度可能比buffer 短
  string received = Encoding.UTF8.GetString(buffer, 0, read); - binary → text
  # 使用 UTF-8 編碼格式解析(資料陣列,解碼起始位置,解碼長度)
}}
}}
Java 
{{Server
{{程式碼
  import java.net.ServerSocket;
  import java.net.Socket;
  import java.nio.charset.StandardCharsets;
  import java.util.Random;
  # 引入用來處理 TCP socket 通訊 (ServerSocket, Socket)。
  # StandardCharsets：用來指定 UTF-8 編碼。
  # Random：用來產生亂數模擬生理數據。
  
  public class TcpServer {
      public static void main(String[] args) {
          try (var ServerSocket = new ServerSocket(9000)) {
  		# 使用 try-with-resources 確保 ServerSocket 在關閉時能自動釋放資源
  		# 開啟一個 TCP 伺服器，監聽本機的 9000 埠口
              System.out.println("Server started, waitting for connecting...");
  
              while (true){
                  var clientSocket = ServerSocket.accept();
  				# ServerSocket.accept() 是 阻塞式呼叫，直到有 client 連進來才會繼續
                  System.out.println("Client connected");
                  new Thread(() -> handleClient(clientSocket)).start();
  				# 每當有一個 client 連進來，就開一個 新執行緒 來處理這個連線，讓主執行緒繼續等待其他 client。
              }
          } catch (Exception e) {
              System.out.println(e.getMessage());
          }
      }
      public static void handleClient(Socket clientSocket){
          Random random = new Random();
          try(var out = clientSocket.getOutputStream()){
  		# 建立輸出資料流 out，這是發送資料給 client 用
              while (true){
                  String data = String.format(
                          "{\"ECG\":%d,\"BP\":%d,\"Pulse\":%d}\n",
                          random.nextInt(40,70),
                          random.nextInt(100,170),
                          random.nextInt(110,155)
                  );
                  out.write(data.getBytes(StandardCharsets.UTF_8));
  				# 將 JSON 字串轉成 UTF-8 bytes 傳送給 client。
                  out.flush();
                  System.out.print("client receive:" + data);
                  Thread.sleep(1000);
              }
  
          }
          catch(Exception e){
              System.out.println("Client disconnected" + e.getMessage());
          }
      }
  }
}}
{{知識 :
  ServerSocket - 建立 - var ServerSocket = new ServerSocket(9000)  # 不指定IP
				    - InetAddress ip = InetAddress.getByName("127.0.0.1"); # 指定IP
					  ServerSocket serverSocket = new ServerSocket(9000, 50, ip); # (port,backlog,bindAddr) 
				   	  # backlog 等待佇列長度 - 容納多少尚未服務的連線請求(50 ~ 100)
			 - 方法 - accept() - 阻塞式等待 client 連線，回傳一個 Socket
					 close()	- 關閉 socket，釋放 port 資源
					 isClosed() - 檢查是否已經關閉
					 getInetAddress() - 取得綁定的本機 IP
					 getLocalPort() - 取得正在監聽的 port
  String data = String.format(...) - String.format("格式字串", 參數1, 參數2, ...) - \" - 雙引號要轉義, %d - 格式化整數, \n - 換行符號
  # 模擬的 JSON 格式資料字串 - 易於在 client 端解析
  OutputStream - 取得 - var out = clientSocket.getOutputStream()
			  - 方法 - write(byte[]) - 寫入整個 byte 陣列
					  write(int b) - 寫入單一 byte	
					  write(byte[], int off, int len) - 寫入部分陣列 # (陣列,起始index,長度)
					  write(data.getBytes(StandardCharsets.UTF_8)) - 字串資料轉成 UTF-8 編碼的位元組陣,並寫入Buffer
					  flush() - 強制把緩衝區資料送出
					  close() - 關閉 stream
  try-with-resources - 資源自動關閉 - try(var out = clientSocket.getOutputStream()){...} # 不用手動呼叫 out.close()
}}
}}
{{Client
{{程式碼 :
  import java.io.BufferedReader;
  import java.io.InputStreamReader;
  import java.net.Socket;
  import java.nio.charset.StandardCharsets;
  
  public class TcpClient {
      public static void main(String[] args) {
          try{var socket = new Socket("127.0.0.1",9000);
              var reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));
              System.out.println("Serverr connected, started to receiving data...");
  
              String line;
              while ((line = reader.readLine()) != null){
                  System.out.println("data received" + line);
              }
          }catch (Exception e){
              System.out.println("Error" + e.getMessage());
          }
  
      }
  }
}}
知識 - BufferedReader - 加上buffer - 提供高階 API, readLine() # 可一次讀整行字串
	  InputStreamReader -  byte -> char - 解碼器 # 一個字元一個字元地讀取
	  socket.getInputStream() - 從socket中讀取原始byte資料 # 最低階的資料流，只能處理 byte(0~255)
	  # var reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));
}}
{{Java/CSharp - TCP Server 比較
					Java										CSharp
套件  	| 	ServerSocket/Socket				|   		TcpListener/TcpClient/Socket
監聽		| 	new ServerSocket(port)				|		new TcpListener(IPAddress, port)
等待連線	| 		accept()						|		AcceptTcpClient()/AcceptSocket()
傳輸資料	|  getInputStream()/getOutputStream()		|		GetStream() - 回傳 NetworkStream
編碼	 	| InputStreamReader/OutputStreamWriter 	|	搭配 Encoding.UTF8.GetString()/StreamReader/StreamWriter
		|  搭配 UTF-8 - StandardCharsets.UTF_8	|    new StreamReader/Writer(stream, Encoding.UTF8);
線程處理	| new Thread(() -> { ... }).start()			|	new Thread(() => { ... }).Start()/async/await
關閉連線	| 		socket.close()					|				client.Close()
-------------------------------------------------------------------------------------------------------------------------------------------   
}}